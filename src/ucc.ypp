%{
#include <cstdio>
#include <string>

#include "debug.hpp"

#include "type.hpp"
#include "list.hpp"
#include "symtab.hpp"
#include "data.hpp"
#include "trans.hpp"
#include "lex.hpp"
#include "cpptypes.hpp"

using namespace ucc;
#define YYDEBUG 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYERROR_VERBOSE 1

#include "compiler.hpp"
//Funcb* currentFunc;

int yyerror(std::string err,Compiler& compiler);
%}
%verbose
%define parse.trace
%require "3.7"
%expect 1
%skeleton "lalr1.cc"

//%define parse.assert

%defines
%locations
%define api.value.type variant
//%define api.token.constructor
%define api.token.raw

%define api.namespace{ucc}
%define api.parser.class {uccParser}

%code requires {
	namespace ucc{
		class Compiler;
		class TableEntry;
	}
	#include "cpptypes.hpp"
	#include "list.hpp"
	#include "type.hpp"
	using namespace ucc;

	# if !defined __EXCEPTIONS
	#  define YY_EXCEPTIONS 0
	# else
	#  define YY_EXCEPTIONS 1
	# endif
}

%parse-param{ Compiler& compiler }
//%lex-param{ uccParser::semantic_type* const lval }
//%lex-param{ uccParser::location_type* loc }
%code{
	#undef yylex
	#define yylex compiler.lexer.yylex
	
	void ucc::uccParser::error(ucc::location const & loc, const std::string & message){
		std::cout << "at " << loc << " : " << message << std::endl;
	}
} 


%token <ucc::Identifier> Ident "Identifier"
%token <ucc::IntConstant> IntConstant "IntConstant"
%token <ucc::FloatConstant> FloatConstant "FloatConstant"
%token <ucc::StrConstant> StrConstant "StrConstant"
%token voidt
%token intt
%token floatt
%token chart
%token ift
%token whilet
%token returnt
%token elset
%token equequ
%token neq
%token leq
%token geq
%token adof
%token elip
%token lpar
%token rpar
%token lcbra
%token rcbra
%token semi
%token comma
%token lesst
%token greatt
%token equalt
%token plus
%token minus
%token divide
%token star
%token uminus

%right equequ neq
%right lesst greatt
%left leq geq
%left plus minus
%left divide star
%right adof
%right uminus


%type <List*> identlist
%type <reltype> relop
%type <multype> mulop
%type <addtype> addop
%type <eqtype> eqop

%type <int> whilet ift elset
%type <int> intt
%type <float> floatt
%type <int> chart voidt adof elip lpar rpar lcbra rcbra semi comma equalt
%type <reltype> lesst greatt leq geq
%type <addtype> plus minus
%type <eqtype> equequ neq
%type <multype> divide star
%type <int> uminus

%nterm <List*> paramdeflist paramdef
%nterm <funcheadertype*> funcheader
%nterm <ReturnPacket*> expr
%nterm <ReturnPacket*> stmt
%nterm <ReturnPacket*> stmtlist
%nterm <ReturnPacket*> ifexprstmt
%nterm <Constant*> constant
%nterm <ReturnPacket*> factor function_call func_call_with_params name_and_params
%nterm <ReturnPacket*> TERM
%nterm <ReturnPacket*> simpleexpr
%nterm <ReturnPacket*> relexpr
%nterm <ReturnPacket*> equalexpr

%start starter

%%
starter:				translation_unit							{	compiler.block1_start_trans_unit(); }
;

translation_unit:	func											{}
		|				variabledecl								{}
		|				translation_unit func					{}
		|				translation_unit variabledecl			{}
		|				translation_unit error					{	compiler.error("(unexpected token between translation units or at end of program)","");}
;

func:					funcheader									{	compiler.block2_func_funcheader_source(&$1); }
						funcbody										{	compiler.block3_func_funcheader_source_funcbody(); }
		|				funcheader semi							{	compiler.block4_func_funcheader_semi($1); }
		|				funcheader error semi					{	yyerrok; compiler.error("(unexpected token before semi in function)","");
																			compiler.block5_funcheader_error_semi(&$1); }
;

funcheader:			voidt Ident lpar paramdef rpar		{	compiler.block6_funcheader_void_ident_lpar_paramdef_rpar(&$$,$2,$<List*>4); }
		|				intt Ident lpar paramdef rpar			{	compiler.block7_funcheader_int_ident_lpar_paramdef_rpar(&$$,$2,$<List*>4); }
		|				floatt Ident lpar paramdef rpar		{	compiler.block8_funcheader_float_ident_lpar_paramdef_rpar(&$$,$2,$<List*>4); }
		|				voidt error rpar							{	yyerrok; compiler.block9_funcheader_void_error_rpar(&$$);
																			compiler.error("(expecting lpar before rpar in function)",""); }
		|				intt error rpar							{	yyerrok; compiler.block10_funcheader_int_error_rpar(&$$);
																			compiler.error("(expecting lpar before rpar in function)",""); }
		|				floatt error rpar							{	yyerrok; compiler.block11_funcheader_float_error_rpar(&$$);
																			compiler.error("(expecting lpar before rpar in function)",""); }
		|				voidt Ident lpar error rpar 			{	yyerrok; compiler.block12_funcheader_void_ident_lpar_error_rpar(&$$, $2);
																			compiler.error("(unexpected token after lpar and before rpar in function)",""); }
		|				floatt Ident lpar error rpar			{	yyerrok; compiler.block13_funcheader_float_ident_lpar_error_rpar(&$$,$2);
																			compiler.error("(unexpected token after lpar and before rpar in function)",""); }
		|				intt Ident lpar error rpar				{	yyerrok; compiler.block14_funcheader_int_ident_lpar_error_rpar(&$$,$2);
																			compiler.error("(unexpected token after lpar and before rpar in function)",""); }
;

paramdef:			paramdeflist								{	$$ = $1; }
		|				paramdeflist comma elip					{	compiler.block15_paramdef_paramdeflist_comma_elip(&$$,&$1); }
		|				voidt											{	compiler.block16_paramdef_void(&$$); }
		|				paramdeflist error rpar					{	yyerrok; compiler.error("(unexpected token before rpar in parameter definition)","");
																			compiler.block17_paramdef_paramdeflist_error_rpar(&$1); }
		|				paramdeflist comma error rpar			{	yyerrok; compiler.error("(unexpected token before rpar in parameter definition)","");
																			compiler.block18_paramdef_paramdeflist_comma_error_rpar(&$1); }
;

paramdeflist:		intt Ident									{	compiler.block19_paramdeflist_int_ident(&$$,$2); }
		|				floatt Ident								{	compiler.block20_paramdeflist_float_ident(&$$,$2); }
		|				chart star Ident 							{	compiler.block21_paramdeflist_char_star_ident(&$$,$3); }
		|				paramdeflist comma intt Ident			{	compiler.block22_paramdeflist_paramdeflist_comma_int_ident(&$$,&$1,$4); }
		|				paramdeflist comma floatt Ident		{	compiler.block23_paramdeflist_paramdeflist_comma_float_ident(&$$,&$1,$4); }
		|				paramdeflist comma chart star Ident	{	compiler.block24_paramdeflist_paramdeflist_comma_char_star_ident(&$$,&$1,$5); }
;

funcbody:			lcbra decls									{	compiler.block25_funcbody_lcbra_decls_source(); } 
						stmtlist rcbra								{	compiler.block26_funcbody_lcbra_decls_source_stmtlist_rcbra(); }
;

decls:  /*empty*/
		|				decls variabledecl						{} //$<value.lstvalue>$ = $<value.lstvalue>2;
		|				decls func									{}
;

variabledecl:		intt identlist semi						{	compiler.block27_variabledecl_int_identlist_semi(&$2); }
		|				floatt identlist semi					{	compiler.block28_variabledecl_float_identlist_semi(&$2); }
		|				error semi									{	yyerrok; compiler.error("(unexpected token in variable decl)",""); }
;

stmtlist:			stmtlist stmt 								{}
		|				stmt 											{}
;

stmt: 				expr semi									{	compiler.block29_stmt_expr_semi(); }
		|				returnt semi								{	compiler.block30_stmt_return_semi(); }
		|				returnt expr semi 						{	compiler.block31_stmt_return_expr_semi(&$2); }

		|				whilet										<ReturnPacket*>{	compiler.block32_stmt_while_source(&$$); }
						lpar expr rpar								{	compiler.block33_stmt_while_source_expr_semi_source_lpar_expr_rpar(&$2,&$4); }
						stmt											{	compiler.block34_stmt_while_source_expr_semi_source_lpar_expr_rpar_source_stmt(&$2,&$4); }

		|				ifexprstmt 
						elset											{	compiler.block35_stmt_ifexprstmt_else(&$1); }
						stmt											{	compiler.block36_stmt_ifexprstmt_else_source_stmt(&$1); }

		|				ifexprstmt									{	compiler.block37_stmt_ifexprstmt(&$1); }

		|				lcbra stmtlist rcbra 					{} //closescope(mysymtab);
		|				returnt error								{	yyerrok; compiler.error("(unexpected token after return in return stmt)","");}
		|				whilet error semi							{	yyerrok; compiler.error("(unexpected token before semi in while stmt)","");}
		|				ift error stmt								{	yyerrok; compiler.error("(unexpected token before stmt in if stmt)","");}
		|				lcbra stmtlist error rcbra				{	yyerrok; compiler.error("(unexpected token before rcbra in stmt)",""); }	//closescope(mysymtab);
;

ifexprstmt:			ift lpar expr								<struct Pair	>{	compiler.block38_ifexprstmt_if_lpar_expr_source(&$$, &$3); }
						rpar stmt									{	$$ = $3; $$->m_pair = $4; }
;

expr:					equalexpr equalt equalexpr				{	compiler.block40_expr_equalexpr_equal_equalexpr(&$$,&$1, &$3); }
		|				equalexpr									{	$$ = $1; }
		|				equalexpr equalt error					{	yyerrok; compiler.error("(unexpected token after equalt operator in expr)","");}
;

equalexpr:			relexpr eqop								{	compiler.block42_equalexpr_relexpr_eqop_source(&$1); }
						relexpr										{	compiler.block43_equalexpr_relexpr_eqop_source_relexpr(&$$,$2,&$1,&$4); }
		|				relexpr										{	$$ = $1; }
		|				relexpr eqop error						{	yyerrok; compiler.error("(unexpected token after equality operator in expr)","");}
;

relexpr:				simpleexpr relop							{	compiler.block45_relexpr_simpleexpr_relop_source(&$1); }
						simpleexpr 									{	compiler.block46_relexpr_simpleexpr_relop_source_simpleexpr(&$$,&$1,$2,&$4); }
		|				simpleexpr									{	$$ = $1; }
		|				simpleexpr relop error					{	yyerrok; compiler.error("(unexpected token after relational operator",""); }
;

simpleexpr:			simpleexpr addop							{	compiler.block48_simpleexpr_simpleexpr_addop_source(&$1); }
						TERM											{	compiler.block49_simpleexpr_simpleexpr_addop_source_term(&$$,&$1,$2,&$4); }
		|				TERM											{	$$ = $1; }
		|				simpleexpr addop error					{	yyerrok; compiler.error("(unexpected token after additive operator)","");}
;

TERM:					TERM mulop									{	compiler.block51_term_term_mulop_source(&$1); }
						factor										{	compiler.block52_term_term_mulop_source_factor(&$$,&$1,$2,&$4); }
		|				factor										{	$$ = $1; }
		|				TERM mulop error							{	yyerrok; compiler.error("(unexpected token after multiplicative operator)",""); }
;

factor:				constant										{	compiler.block54_factor_constant(&$$,&$1); }
		|				Ident											{	compiler.block55_factor_ident(&$$, $1); }
		|				lpar expr rpar								{	$$ = $2; }
		|				addop factor %prec uminus				{	compiler.block57_factor_addop_factor_uminus(&$$,$1,&$2); }
		|				adof Ident									{	compiler.block58_factor_adof_ident(&$$,$2); }
		|				function_call								{	$$ = $1; }
		|				addop error									{	yyerrok; compiler.error("(unexpected token after unary additive operator)",""); }
		|				lpar expr error rpar						{	yyerrok; compiler.error("(unexpected token before rpar)",""); }
;

function_call:		Ident lpar rpar							{	compiler.block60_function_call_ident_lpar_rpar(&$$, $1); }
		|				func_call_with_params					{	$$ = $1; }
;

func_call_with_params: name_and_params rpar				{	compiler.block62_func_call_with_params_name_and_params_rpar(&$$,&$1); }
;

name_and_params:	Ident lpar									<ReturnPacket*>{	compiler.block63_name_and_params_ident_lpar_source(&$$,$1); }
						expr											{	compiler.block64_name_and_params_ident_lpar_source_expr(&$$,$1,&$3,&$4); }
		|				name_and_params comma {} expr			{	compiler.block65_name_and_params_name_and_params_comma_expr(&$$, &$1, &$4); }
;


identlist:			Ident											{	compiler.block69_identlist_ident(&$$,$1); }
		|				identlist comma Ident					{	compiler.block70_identlist_comma_ident(&$$,&$1,$3); }
		|				identlist comma error					{	yyerrok; compiler.error("(unexpected token after comma)",""); }
;

constant:			StrConstant									{	$$ = new StrConstant{$1}; }
		|				IntConstant									{	$$ = new IntConstant{$1}; }
		|				FloatConstant								{	$$ = new FloatConstant{$1}; }
;

addop:				plus											{	$$ = $1;}
		|				minus											{	$$ = $1;}
;

mulop:				star											{	$$ = $1;}
		|				divide										{	$$ = $1;}
;

eqop:					equequ										{	$$ = $1;}
		|				neq											{	$$ = $1;}
;

relop:				lesst											{	$$ = $1;}
		|				leq											{	$$ = $1;}
		|				geq											{	$$ = $1;}
		|				greatt										{	$$ = $1;}
;

%%
#include <iostream>
int yyerror(std::string s, Compiler& compiler)
//int ucc::uccParser::error(std::string s, Compiler& compiler)
{
	std::cerr << "Error:::"<< compiler.filename << ":"<< compiler.Line_Number << "-> " << s << "\n";
    return 0;
}