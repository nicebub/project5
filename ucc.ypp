/*scott lorberbaum
   compilers spring 2004
	This file is the specification file for bison for the uC language.  This is only the minimal amount need to create the ucc.tab.h file which specifies the tokens
and their values.  Then that file is included in the flex spec file to have identical tokens.  Also there is a declartion of a union, the Line_Number which helps keep
track of the line number, and some of the operators have their precedence specifed.
*/
%{
#include <cstdio>
#include <string>
#ifdef DEBUGON
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include "type.hpp"
#include "List.hpp"
#include "symtab.hpp"
#include "data.hpp"
#include "trans.hpp"

using namespace ucc;
//#define yyerrok
#define YYDEBUG 0
#define YYERROR_VERBOSE 1
#define YYSTYPE ucc::data

#include "compiler.hpp"

//#include "main.h"

//extern int Line_Number;
//bool founderror=false;
//extern int globalcount;
//extern int mainlocal;
//extern int othercounter;
//extern int param_offset;
//extern int offset_counter;
extern Compiler* compiler;
//extern Symtab* mysymtab;
//int mainlabel;
Funcb* currentFunc;

extern int yyerror(std::string);
//extern int yylex (void);
extern int warning(std::string,std::string);
extern int error(std::string,std::string);
%}
%expect 1
%skeleton "lalr1.cc"
%require "3.0"

%define api.namespace{ucc}
%define api.parser.class {uccParser}
%code requires {
	class Compiler;
}

%parse-param{ Compiler& compiler}

%code{
	#undef yylex
	#define yylex compiler.lexer
} 

%define api.value.type variant

%token Ident
%token IntConstant
%token FloatConstant
%token StrConstant
%token voidt
%token intt
%token floatt
%token chart
%token ift
%token whilet
%token returnt
%token elset
%token equequ
%token neq
%token leq
%token geq
%token adof
%token elip
%token lpar
%token rpar
%token lcbra
%token rcbra
%token semi
%token comma
%token lesst
%token greatt
%token equalt
%token plus
%token minus
%token divide
%token star
%token uminus
//%token uplus

%right equequ neq
%right lesst greatt
%left leq geq
%left plus minus
%left divide star
%right adof
%right uminus


%type <value.lstvalue> identlist
%type <value.relopvalue> relop
%type <value.multopvalue> mulop
%type <value.addopvalue> addop
%type <value.eqopvalue> eqop
%type <value.svalue> Ident
%type <value.ivalue> IntConstant
%type <value.fvalue> FloatConstant
%type <value.svalue> StrConstant
%type <value.ivalue> whilet ift elset
%type <value.ivalue> intt
%type <value.fvalue> floatt
%type <value.ivalue> chart voidt adof elip lpar rpar lcbra rcbra semi comma equalt
%type <value.relopvalue> lesst greatt leq geq
%type <value.addopvalue> plus minus
%type <value.eqopvalue> equequ neq
%type <value.multopvalue> divide star
%type <value.ivalue> uminus
%type <value.lstpvalue> paramdeflist
%type <value.funcheadervalue> funcheader
//%type <value.lstevalue> exprlist
%type <value.exprvalue> expr
//%type <value.exprvalue>simpleexpr relexpr equalexpr
//%type <data> equalexpr relexpr simpleexpr
//%type <data> stmt ifexprstmt
//%type <data> term factor function_call func_call_with_params name_and_params constant


%start starter
%%

starter:				translation_unit							{	compiler->block1_start_trans_unit(); }
;

translation_unit:	func											{}
		|				variabledecl								{}
		|				translation_unit func					{}
		|				translation_unit variabledecl			{}
		|				translation_unit error					{	error("(unexpected token between translation units or at end of program)","");}
;

func:					funcheader									{	compiler->block2_func_funcheader_source(); }
						funcbody										{	compiler->block3_func_funcheader_source_funcbody(); }
		|				funcheader semi							{	compiler->block4_func_funcheader_semi(); }
		|				funcheader error semi					{	yyerrok; error("(unexpected token before semi in function)","");
																			compiler->block5_funcheader_error_semi(); }
;


funcheader:			voidt Ident lpar paramdef rpar		{	compiler->block6_funcheader_void_ident_lpar_paramdef_rpar(); }
		|				intt Ident lpar paramdef rpar			{	compiler->block7_funcheader_int_ident_lpar_paramdef_rpar(); }
		|				floatt Ident lpar paramdef rpar		{	compiler->block8_funcheader_float_ident_lpar_paramdef_rpar(); }
		|				voidt error rpar							{	compiler->block9_funcheader_void_error_rpar();
																			error("(expecting lpar before rpar in function)",""); }
		|				intt error rpar							{	compiler->block10_funcheader_int_error_rpar();
																			error("(expecting lpar before rpar in function)",""); }
		|				floatt error rpar							{	compiler->block11_funcheader_float_error_rpar();
																			error("(expecting lpar before rpar in function)",""); }
		|				voidt Ident lpar error rpar 			{	compiler->block12_funcheader_void_ident_lpar_error_rpar();
																			error("(unexpected token after lpar and before rpar in function)",""); }
		|				floatt Ident lpar error rpar			{	compiler->block13_funcheader_float_ident_lpar_error_rpar();
																			error("(unexpected token after lpar and before rpar in function)",""); }
		|				intt Ident lpar error rpar				{	compiler->block14_funcheader_int_ident_lpar_error_rpar();
																			error("(unexpected token after lpar and before rpar in function)",""); }
;


paramdef:			paramdeflist								{	compiler->block15_paramdef_paramdeflist(); }
		|				paramdeflist comma elip					{	compiler->block15_paramdef_paramdeflist_comma_elip(); }
		|				voidt											{	compiler->block16_paramdef_void(); }
		|				paramdeflist error rpar					{	yyerrok; error("(unexpected token before rpar in parameter definition)","");
																			compiler->block17_paramdef_paramdeflist_error_rpar(); }
		|				paramdeflist comma error rpar			{	yyerrok; error("(unexpected token before rpar in parameter definition)","");
																			compiler->block18_paramdef_paramdeflist_comma_error_rpar(); }
;

paramdeflist:		intt Ident									{	compiler->block19_paramdeflist_int_ident(); }
		|				floatt Ident								{	compiler->block20_paramdeflist_float_ident(); }
		|				chart star Ident 							{	compiler->block21_paramdeflist_char_star_ident(); }
		|				paramdeflist comma intt Ident			{	compiler->block22_paramdeflist_paramdeflist_comma_int_ident(); }
		|				paramdeflist comma floatt Ident		{	compiler->block23_paramdeflist_paramdeflist_comma_float_ident(); }
		|				paramdeflist comma chart star Ident	{	compiler->block24_paramdeflist_paramdeflist_comma_char_star_ident(); }
;


funcbody:			lcbra decls									{	compiler->block25_funcbody_lcbra_decls_source(); } 
						stmtlist rcbra								{	compiler->block26_funcbody_lcbra_decls_source_stmtlist_rcbra(); }
;


decls:  /*empty*/
		|				decls variabledecl						{} //$<value.lstvalue>$ = $<value.lstvalue>2;
		|				decls func									{}
;


variabledecl:		intt identlist semi						{	compiler->block27_variabledecl_int_identlist_semi(); }
		|				floatt identlist semi					{	compiler->block28_variabledecl_float_identlist_semi(); }
		|				error semi									{	yyerrok; error("(unexpected token in variable decl)",""); }
;


stmtlist:			stmtlist stmt 								{}
		|				stmt 											{}
;

stmt: 				expr semi									{	compiler->block29_stmt_expr_semi(); }
		|				returnt semi								{	compiler->block30_stmt_return_semi(); }
		|				returnt expr semi 						{	compiler->block31_stmt_return_expr_semi(); }

		|				whilet										{	compiler->block32_stmt_while_source(); }
						lpar expr rpar								{	compiler->block33_stmt_while_source_expr_semi_source_lpar_expr_rpar(); }
						stmt											{	compiler->block34_stmt_while_source_expr_semi_source_lpar_expr_rpar_source_stmt(); }

		|				ifexprstmt 
						elset											{	compiler->block35_stmt_ifexprstmt_else(); }
						stmt											{	compiler->block36_stmt_ifexprstmt_else_source_stmt(); }

		|				ifexprstmt									{	compiler->block37_stmt_ifexprstmt(); }

		|				lcbra stmtlist rcbra 					{} //closescope(mysymtab);
		|				returnt error								{	yyerrok; error("(unexpected token after return in return stmt)","");}
		|				whilet error semi							{	yyerrok; error("(unexpected token before semi in while stmt)","");}
		|				ift error stmt								{	yyerrok; error("(unexpected token before stmt in if stmt)","");}
		|				lcbra stmtlist error rcbra				{	yyerrok; error("(unexpected token before rcbra in stmt)",""); }	//closescope(mysymtab);
;

ifexprstmt:			ift lpar expr								{	compiler->block38_ifexprstmt_if_lpar_expr_source(); }
						rpar stmt									{	compiler->block39_ifexprstmt_if_lpar_expr_source_rpar_stmt(); }
;

expr:					equalexpr equalt equalexpr				{	compiler->block40_expr_equalexpr_equal_equalexpr(); }
		|				equalexpr									{	compiler->block41_expr_equalexpr(); }
		|				equalexpr equalt error					{	yyerrok; error("(unexpected token after equalt operator in expr)","");}
;

equalexpr:			relexpr eqop								{	compiler->block42_equalexpr_relexpr_eqop_source(); }
						relexpr										{	compiler->block43_equalexpr_relexpr_eqop_source_relexpr(); }
		|				relexpr										{	compiler->block44_equalexpr_relexpr(); }
		|				relexpr eqop error						{	yyerrok; error("(unexpected token after equality operator in expr)","");}
;

relexpr:				simpleexpr relop							{	compiler->block45_relexpr_simpleexpr_relop_source(); }
						simpleexpr 									{	compiler->block46_relexpr_simpleexpr_relop_source_simpleexpr(); }
		|				simpleexpr									{	compiler->block47_relexpr_simpleexpr(); }
		|				simpleexpr relop error					{	yyerrok; error("(unexpected token after relational operator",""); }
;

simpleexpr:			simpleexpr addop							{	compiler->block48_simpleexpr_simpleexpr_addop_source(); }
						term											{	compiler->block49_simpleexpr_simpleexpr_addop_source_term(); }
		|				term											{	compiler->block50_simpleepr_term(); }
		|				simpleexpr addop error					{	yyerrok; error("(unexpected token after additive operator)","");}
;

term:					term mulop									{	compiler->block51_term_term_mulop_source(); }
						factor										{	compiler->block52_term_term_mulop_source_factor(); }
		|				factor										{	compiler->block53_term_factor(); }
		|				term mulop error							{	yyerrok; error("(unexpected token after multiplicative operator)",""); }
;

factor:				constant										{	compiler->block54_factor_constant(); }
		|				Ident											{	compiler->block55_factor_ident(); }
		|				lpar expr rpar								{	compiler->block56_factor_lpar_expr_rpar(); }
		|				addop factor %prec uminus				{	compiler->block57_factor_addop_factor_uminus(); }
		|				adof Ident									{	compiler->block58_factor_adof_ident(); }
		|				function_call								{	compiler->block59_factor_function_call(); }
		|				addop error									{	yyerrok; error("(unexpected token after unary additive operator)",""); }
		|				lpar expr error rpar						{	yyerrok; error("(unexpected token before rpar)",""); }
;

function_call:		Ident lpar rpar							{	compiler->block60_function_call_ident_lpar_rpar(); }
		|				func_call_with_params					{	compiler->block61_function_call_func_call_with_params(); }
;

func_call_with_params: name_and_params rpar				{	compiler->block62_func_call_with_params_name_and_params_rpar(); }
;

name_and_params:	Ident lpar									{	compiler->block63_name_and_params_ident_lpar_source(); }
						expr											{	compiler->block64_name_and_params_ident_lpar_source_expr(); }
		|				name_and_params comma {} expr			{	compiler->block65_name_and_params_name_and_params_comma_expr(); }
;

constant:			StrConstant									{	compiler->block66_constant_strconstant(); }
		|				IntConstant									{	compiler->block67_constant_intconstant(); }
		|				FloatConstant								{	compiler->block68_constant_floatconstant(); }
;


identlist:			Ident											{	compiler->block69_identlist_ident(); }
		|				identlist comma Ident					{	compiler->block70_identlist_comma_ident(); }
		|				identlist comma error					{	yyerrok; error("(unexpected token after comma)",""); }
;


addop: plus { $$ = $1;}
	| minus { $$ = $1;}
;

mulop: star { $$ = $1;}
	| divide {$$ = $1;}
;

eqop: equequ { $$ = $1;}
	| neq { $$ = $1;}
;

relop: lesst { $$ = $1;}
	| leq { $$ = $1;}
	| geq { $$ = $1;}
	| greatt { $$ = $1;}
;


%%
#include <iostream>
int yyerror(std::string s)
{
	std::cerr << "Error:::"<< Compiler::filename << ":"<< Compiler::Line_Number << "-> " << s << "\n";
    return 0;
}